"""
Deni Avdija: 360Â° Performance Analytics Dashboard

This Streamlit app loads all data from nba_data.pkl (generated by fetch_data.py).
No API calls are made - all data is loaded from the local pickle file.

Before running this app, you must first run: python fetch_data.py
"""

import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
import streamlit as st
import os
import pickle
import numpy as np
from pathlib import Path
from datetime import datetime

# -----------------------------
# Config and constants
# -----------------------------
PLAYER_NAME = "Deni Avdija"
CURRENT_SEASON = "2025-26"
DATA_FILE = "nba_data.pkl"

st.set_page_config(
    page_title="Deni Avdija: 360Â° Performance Analytics",
    layout="wide",
)


# -----------------------------
# Data Loading (from pickle file)
# -----------------------------
@st.cache_data(show_spinner=False)
def load_nba_data() -> dict:
    """Load all NBA data from pickle file."""
    if not Path(DATA_FILE).exists():
        return {}
    
    try:
        with open(DATA_FILE, "rb") as f:
            data = pickle.load(f)
        return data
    except Exception as e:
        st.error(f"âŒ Error loading data file: {e}")
        return {}


def get_file_mod_time() -> str:
    """Get the last modified time of the data file."""
    if not Path(DATA_FILE).exists():
        return "N/A"
    try:
        mod_time = os.path.getmtime(DATA_FILE)
        return datetime.fromtimestamp(mod_time).strftime("%Y-%m-%d %H:%M:%S")
    except Exception:
        return "N/A"


# -----------------------------
# Transform helpers
# -----------------------------
def merge_career_frames(basic_df: pd.DataFrame, adv_df: pd.DataFrame) -> pd.DataFrame:
    """Merge basic and advanced frames on SEASON_ID."""
    if basic_df.empty or adv_df.empty:
        return pd.DataFrame()
    adv_cols = ["SEASON_ID", "NET_RATING", "AST_TO", "TS_PCT", "USG_PCT"]
    missing_cols = [c for c in adv_cols if c not in adv_df.columns]
    if missing_cols:
        st.warning(f"Advanced data missing columns: {', '.join(missing_cols)}")
        return pd.DataFrame()
    merged = basic_df.merge(adv_df[adv_cols], on="SEASON_ID", how="inner")
    merged = merged.sort_values("SEASON_ID")
    return merged


# -----------------------------
# Plot builders
# -----------------------------
def plot_per_game_stats(df: pd.DataFrame) -> go.Figure:
    """Per Game Stats - Grouped Bar Chart (PTS, REB, AST)."""
    fig = go.Figure()
    
    metrics = ["PTS", "REB", "AST"]
    colors = ["#1f77b4", "#2ca02c", "#ff7f0e"]  # Blue, Green, Orange
    
    for metric, color in zip(metrics, colors):
        fig.add_trace(
            go.Bar(
                name=metric,
                x=df["SEASON_ID"],
                y=df[metric],
                marker_color=color,
                hovertemplate=f"{metric}: %{{y:.1f}}<extra></extra>",
            )
        )
    
    fig.update_layout(
        title="×ž×ž×•×¦×¢×™× ×œ×ž×©×—×§ (Per Game)",
        xaxis_title="Season",
        yaxis_title="Value",
        barmode="group",
        hovermode="x unified",
        showlegend=True,
    )
    return fig


def plot_per_36_stats(df: pd.DataFrame) -> go.Figure:
    """Per 36 Minutes Stats - Grouped Bar Chart (PTS, REB, AST, STL, TOV)."""
    fig = go.Figure()
    
    # All possible metrics we want to show
    all_metrics = ["PTS", "REB", "AST", "STL", "TOV"]
    all_colors = ["#1f77b4", "#2ca02c", "#ff7f0e", "#9467bd", "#d62728"]  # Blue, Green, Orange, Purple, Red
    
    # Filter to only metrics that exist in the dataframe
    available_metrics = [m for m in all_metrics if m in df.columns]
    available_colors = [all_colors[all_metrics.index(m)] for m in available_metrics]
    
    df_work = df.copy()
    
    # Check if we have MIN column for calculation
    if "MIN" in df.columns:
        # Calculate Per36 for each available metric
        for metric in available_metrics:
            # Avoid division by zero
            df_work[f"{metric}_PER36"] = df_work.apply(
                lambda row: (row[metric] / row["MIN"]) * 36 if row["MIN"] > 0 else 0,
                axis=1
            )
    
    # Add traces for each available metric
    for metric, color in zip(available_metrics, available_colors):
        col_name = f"{metric}_PER36" if "MIN" in df.columns else metric
        if col_name in df_work.columns:
            fig.add_trace(
                go.Bar(
                    name=metric,
                    x=df_work["SEASON_ID"],
                    y=df_work[col_name],
                    marker_color=color,
                    hovertemplate=f"{metric} (Per 36): %{{y:.1f}}<extra></extra>",
                )
            )
    
    fig.update_layout(
        title="×™×¢×™×œ×•×ª ×œ×“×§×” (×ž× ×•×¨×ž×œ ×œ-36 ×“×§×•×ª)",
        xaxis_title="Season",
        yaxis_title="Value (Per 36 Minutes)",
        barmode="group",
        hovermode="x unified",
        showlegend=True,
    )
    return fig


def plot_usage_growth(df: pd.DataFrame) -> go.Figure:
    """Usage Rate Growth - Line Chart."""
    fig = go.Figure()
    fig.add_trace(
        go.Scatter(
            x=df["SEASON_ID"],
            y=df["USG_PCT"],
            mode="lines+markers",
            name="Usage %",
            line=dict(color="#1f77b4", width=3),
            marker=dict(size=8),
            hovertemplate="Season: %{x}<br>Usage %: %{y:.2%}<extra></extra>",
            )
        )
    fig.update_layout(
        title="×¢×œ×™×™×” ×‘× ×¤×— ×”×©×™×ž×•×© (Usage %)",
        xaxis_title="Season",
        yaxis_title="Usage Percentage",
        hovermode="x unified",
        yaxis=dict(tickformat=".0%"),
    )
    return fig


def plot_ts_growth(df: pd.DataFrame) -> go.Figure:
    """True Shooting Growth - Line Chart with League Average."""
    fig = go.Figure()
    fig.add_trace(
        go.Scatter(
            x=df["SEASON_ID"],
            y=df["TS_PCT"],
            mode="lines+markers",
            name="True Shooting %",
            line=dict(color="#2ca02c", width=3),
            marker=dict(size=8),
            hovertemplate="Season: %{x}<br>TS %: %{y:.2%}<extra></extra>",
        )
    )
    # Add league average line
    fig.add_hline(
        y=0.58,
        line_dash="dash",
        line_color="gray",
        annotation_text="League Average (0.58)",
        annotation_position="right",
    )
    fig.update_layout(
        title="×©×™×¤×•×¨ ×‘×™×¢×™×œ×•×ª ×§×œ×™×¢×” (True Shooting %)",
        xaxis_title="Season",
        yaxis_title="True Shooting Percentage",
        hovermode="x unified",
        yaxis=dict(tickformat=".0%"),
    )
    return fig


def plot_allstar_comparison(deni_stats: dict, allstar_df: pd.DataFrame) -> tuple[go.Figure, dict, pd.DataFrame]:
    """Grouped bar chart comparing Deni to All-Star average and bottom 4 entry level. Returns figure, stats dict, and bottom 4 df."""
    if allstar_df.empty or not deni_stats:
        fig = go.Figure()
        fig.update_layout(title="All-Star Comparison")
        return fig, {}, pd.DataFrame()
    
    # Get weighted averages and round to 1 decimal
    total_gp = allstar_df["GP"].sum()
    if total_gp == 0:
        fig = go.Figure()
        fig.update_layout(title="All-Star Comparison")
        return fig, {}, pd.DataFrame()
    
    allstar_pts = round((allstar_df["PTS"] * allstar_df["GP"]).sum() / total_gp, 1)
    allstar_reb = round((allstar_df["REB"] * allstar_df["GP"]).sum() / total_gp, 1)
    allstar_ast = round((allstar_df["AST"] * allstar_df["GP"]).sum() / total_gp, 1)
    
    # Get Deni's stats (use current season averages) and round to 1 decimal
    deni_pts = round(deni_stats.get("PTS", 0), 1)
    deni_reb = round(deni_stats.get("REB", 0), 1)
    deni_ast = round(deni_stats.get("AST", 0), 1)
    
    # Get bottom 4 All-Stars (sorted by PTS ascending)
    bottom_4_df = allstar_df.nsmallest(4, "PTS").copy()
    bottom_4_df = bottom_4_df.sort_values("PTS", ascending=True)
    
    # Create grouped bar chart
    categories = ["PTS", "REB", "AST"]
    
    fig = go.Figure()
    
    # Deni trace (Green) - Bold and prominent
    fig.add_trace(
        go.Bar(
            name="Deni Avdija (2025-26)",
            x=categories,
            y=[deni_pts, deni_reb, deni_ast],
            marker_color="#2ca02c",  # Green
            text=[deni_pts, deni_reb, deni_ast],
            textposition="outside",
            textfont=dict(size=12, color="black", family="Arial Black"),
            marker=dict(line=dict(width=2, color="darkgreen")),
        )
    )
    
    # All-Star Average trace (Blue)
    fig.add_trace(
        go.Bar(
            name="All-Star Average (2024-25)",
            x=categories,
            y=[allstar_pts, allstar_reb, allstar_ast],
            marker_color="#1f77b4",  # Blue
            text=[allstar_pts, allstar_reb, allstar_ast],
            textposition="outside",
        )
    )
    
    # Bottom 4 Entry Level All-Stars (Light/Transparent)
    for idx, row in bottom_4_df.iterrows():
        player_name = row["PLAYER_NAME"]
        fig.add_trace(
            go.Bar(
                name=f"{player_name} (Entry Level)",
                x=categories,
                y=[round(row["PTS"], 1), round(row["REB"], 1), round(row["AST"], 1)],
                marker_color="rgba(211, 211, 211, 0.4)",  # LightGray with transparency
                text=[round(row["PTS"], 1), round(row["REB"], 1), round(row["AST"], 1)],
                textposition="outside",
                showlegend=True,
                opacity=0.5,
            )
        )
    
    # Add horizontal dashed reference lines for All-Star Average benchmarks
    # These will appear behind the bars as visual guides
    fig.add_shape(
        type="line",
        x0=-0.5, x1=0.5, y0=allstar_pts, y1=allstar_pts,
        line=dict(color="red", width=2, dash="dash"),
        layer="below",
    )
    fig.add_shape(
        type="line",
        x0=0.5, x1=1.5, y0=allstar_reb, y1=allstar_reb,
        line=dict(color="red", width=2, dash="dash"),
        layer="below",
    )
    fig.add_shape(
        type="line",
        x0=1.5, x1=2.5, y0=allstar_ast, y1=allstar_ast,
        line=dict(color="red", width=2, dash="dash"),
        layer="below",
    )
    
    # Add annotations for the average lines
    fig.add_annotation(
        x=0, y=allstar_pts, text=f"Avg: {allstar_pts}",
        showarrow=False, xref="x", yref="y",
        xanchor="left", xshift=10, font=dict(size=9, color="red"),
    )
    fig.add_annotation(
        x=1, y=allstar_reb, text=f"Avg: {allstar_reb}",
        showarrow=False, xref="x", yref="y",
        xanchor="left", xshift=10, font=dict(size=9, color="red"),
    )
    fig.add_annotation(
        x=2, y=allstar_ast, text=f"Avg: {allstar_ast}",
        showarrow=False, xref="x", yref="y",
        xanchor="left", xshift=10, font=dict(size=9, color="red"),
    )
    
    fig.update_layout(
        title="The All-Star Threshold: Deni vs All-Star Average vs Entry Level",
        xaxis_title="Metric",
        yaxis_title="Value (Per Game)",
        barmode="group",
        hovermode="x unified",
        showlegend=True,
    )
    
    stats_dict = {
        "allstar_pts": allstar_pts,
        "allstar_reb": allstar_reb,
        "allstar_ast": allstar_ast,
        "deni_pts": deni_pts,
        "deni_reb": deni_reb,
        "deni_ast": deni_ast,
    }
    
    return fig, stats_dict, bottom_4_df


def plot_separation_chart(allstar_df: pd.DataFrame, deni_stats: dict, career_df_ref: pd.DataFrame = None) -> go.Figure:
    """Scatter plot showing Usage vs True Shooting (The Separation Chart)."""
    if allstar_df.empty or not deni_stats:
        fig = go.Figure()
        fig.update_layout(title="The Separation Chart")
    return fig

    fig = go.Figure()

    # Plot All-Stars
    fig.add_trace(
        go.Scatter(
            x=allstar_df["USG_PCT"] * 100,  # Convert to percentage
            y=allstar_df["TS_PCT"] * 100,
            mode="markers",
            name="All-Stars",
            marker=dict(color="LightGray", size=10),
            text=allstar_df["PLAYER_NAME"],
            hovertemplate="%{text}<br>Usage: %{x:.1f}%<br>TS%: %{y:.1f}%<extra></extra>",
        )
    )
    
    # Plot Deni
    deni_usg = deni_stats.get("USG_PCT", 0)
    deni_ts = deni_stats.get("TS_PCT", 0)
    
    # Convert to percentage if needed
    if isinstance(deni_usg, (int, float)) and deni_usg <= 1:
        deni_usg = deni_usg * 100
    if isinstance(deni_ts, (int, float)) and deni_ts <= 1:
        deni_ts = deni_ts * 100
    
    # Get from career_df_ref if available
    if (deni_usg == 0 or deni_ts == 0) and career_df_ref is not None and not career_df_ref.empty:
        latest = career_df_ref.iloc[-1]
        deni_usg = round(latest.get("USG_PCT", 0) * 100, 1)
        deni_ts = round(latest.get("TS_PCT", 0) * 100, 1)
    
    if deni_usg > 0 or deni_ts > 0:
        fig.add_trace(
            go.Scatter(
                x=[round(deni_usg, 1)],
                y=[round(deni_ts, 1)],
                mode="markers+text",
                name="Deni Avdija",
                marker=dict(color="Red", size=18, symbol="star"),
                text=["Deni"],
                textposition="top center",
                hovertemplate=f"Deni Avdija<br>Usage: {deni_usg:.1f}%<br>TS%: {deni_ts:.1f}%<extra></extra>",
            )
        )
        
        # Label top outliers
        if len(allstar_df) > 0:
            top_usage = allstar_df.nlargest(2, "USG_PCT")
            for _, row in top_usage.iterrows():
                fig.add_annotation(
                    x=row["USG_PCT"] * 100,
                    y=row["TS_PCT"] * 100,
                    text=row["PLAYER_NAME"].split()[-1],
                    showarrow=True,
                    arrowhead=2,
                    ax=0,
                    ay=-30,
                    font=dict(size=10),
                )
    
    fig.update_layout(
        title="The Separation Chart: Usage vs True Shooting Efficiency",
        xaxis_title="Usage Percentage (%)",
        yaxis_title="True Shooting Percentage (%)",
        hovermode="closest",
        showlegend=True,
    )
    
    return fig


def plot_triple_threat(allstar_df: pd.DataFrame, deni_stats: dict) -> go.Figure:
    """3D scatter plot showing Points, Rebounds, Assists (The Triple Threat)."""
    if allstar_df.empty or not deni_stats:
        fig = go.Figure()
        fig.update_layout(title="The Triple Threat")
        return fig
    
    fig = go.Figure()
    
    # Get Deni's stats
    deni_pts = round(deni_stats.get("PTS", 0), 1)
    deni_reb = round(deni_stats.get("REB", 0), 1)
    deni_ast = round(deni_stats.get("AST", 0), 1)
    
    # Identify players Deni is better than (better in at least 2 out of 3 categories)
    deni_better_than = []
    deni_worse_than = []
    
    for _, row in allstar_df.iterrows():
        player_pts = row["PTS"]
        player_reb = row["REB"]
        player_ast = row["AST"]
        
        # Count how many categories Deni is better in
        deni_wins = sum([
            deni_pts > player_pts,
            deni_reb > player_reb,
            deni_ast > player_ast,
        ])
        
        if deni_wins >= 2:
            deni_better_than.append(row)
        else:
            deni_worse_than.append(row)
    
    # Plot All-Stars Deni is worse than (or equal to) - Blue
    if deni_worse_than:
        worse_df = pd.DataFrame(deni_worse_than)
        fig.add_trace(
            go.Scatter3d(
                x=worse_df["PTS"],
                y=worse_df["REB"],
                z=worse_df["AST"],
                mode="markers",
                name="All-Stars (Deni Below/Equal)",
                marker=dict(
                    color="#1f77b4",
                    size=8,
                    opacity=0.7,
                ),
                text=worse_df["PLAYER_NAME"],
                hovertemplate="%{text}<br>PTS: %{x:.1f}<br>REB: %{y:.1f}<br>AST: %{z:.1f}<extra></extra>",
            )
        )
    
    # Plot All-Stars Deni is better than - Orange/Red
    if deni_better_than:
        better_df = pd.DataFrame(deni_better_than)
        fig.add_trace(
            go.Scatter3d(
                x=better_df["PTS"],
                y=better_df["REB"],
                z=better_df["AST"],
                mode="markers",
                name=f"All-Stars (Deni Better) [{len(better_df)}]",
                marker=dict(
                    color="#ff7f0e",
                    size=10,
                    opacity=0.8,
                ),
                text=better_df["PLAYER_NAME"],
                hovertemplate="%{text}<br>PTS: %{x:.1f}<br>REB: %{y:.1f}<br>AST: %{z:.1f}<extra></extra>",
            )
        )
    
    # Plot Deni
    fig.add_trace(
        go.Scatter3d(
            x=[deni_pts],
            y=[deni_reb],
            z=[deni_ast],
            mode="markers+text",
            name="Deni Avdija",
            marker=dict(
                color="Green",
                size=15,
                symbol="diamond",
            ),
            text=["Deni"],
            textposition="middle center",
            hovertemplate=f"Deni Avdija<br>PTS: {deni_pts:.1f}<br>REB: {deni_reb:.1f}<br>AST: {deni_ast:.1f}<extra></extra>",
        )
    )
    
    fig.update_layout(
        title=f"The Triple Threat: Points, Rebounds, Assists (3D View) - Deni beats {len(deni_better_than)} All-Stars",
        scene=dict(
            xaxis_title="Points",
            yaxis_title="Rebounds",
            zaxis_title="Assists",
        ),
        hovermode="closest",
    )
    
    return fig


def plot_current_season(logs: pd.DataFrame, season: str) -> go.Figure:
    logs_sorted = logs.sort_values("GAME_DATE")
    bar_colors = ["#2ca02c" if res == "W" else "#d62728" for res in logs_sorted.get("WL", [])]
    fig = go.Figure()
    fig.add_trace(
        go.Bar(
            x=logs_sorted["GAME_DATE"],
            y=logs_sorted["MIN"],
            marker_color=bar_colors,
            name="Minutes Played",
            hovertemplate="Date: %{x|%Y-%m-%d}<br>MIN: %{y}<br>Result: %{customdata}",
            customdata=logs_sorted.get("WL", []),
        )
    )
    fig.add_trace(
        go.Scatter(
            x=logs_sorted["GAME_DATE"],
            y=logs_sorted["PTS"],
            mode="lines+markers",
            yaxis="y2",
            name="Points",
            line=dict(color="#1f77b4", width=3),
        )
    )
    fig.update_layout(
        title=f"{season} Game Impact: Minutes vs Points",
        xaxis_title="Game Date",
        yaxis=dict(title="Minutes Played"),
        yaxis2=dict(title="Points", overlaying="y", side="right"),
        hovermode="x unified",
    )
    return fig


def draw_nba_court(fig=None):
    """Create a Plotly figure with NBA half-court lines drawn as shapes using exact NBA dimensions."""
    if fig is None:
        fig = go.Figure()

    # NBA Court Dimensions (Units: Tenths of a foot)
    # X axis: -250 to 250 (50 ft width)
    # Y axis: -47.5 to 422.5 (47 ft length - half court)
    
    court_shapes = []

    # 1. Outer Court Boundary (Half Court)
    court_shapes.append(dict(type="rect", x0=-250, y0=-47.5, x1=250, y1=422.5, line=dict(color="black", width=2)))

    # 2. The Paint (Key) - Outer Box (16ft wide)
    court_shapes.append(dict(type="rect", x0=-80, y0=-47.5, x1=80, y1=142.5, line=dict(color="black", width=2)))
    
    # 3. The Paint (Key) - Inner Box (12ft wide)
    court_shapes.append(dict(type="rect", x0=-60, y0=-47.5, x1=60, y1=142.5, line=dict(color="black", width=2)))

    # 4. Hoop & Backboard
    # Hoop is at (0,0), radius 0.75ft = 7.5 units
    court_shapes.append(dict(type="circle", x0=-7.5, y0=-7.5, x1=7.5, y1=7.5, line=dict(color="#ec7607", width=2)))
    # Backboard: 4ft behind center of hoop
    court_shapes.append(dict(type="line", x0=-30, y0=-40, x1=30, y1=-40, line=dict(color="black", width=2)))
    # Stem
    court_shapes.append(dict(type="line", x0=0, y0=-40, x1=0, y1=-7.5, line=dict(color="#ec7607", width=2)))

    # 5. Restricted Area (4ft radius from hoop center)
    # Draw as arc using path
    restricted_arc_x = []
    restricted_arc_y = []
    for i in range(101):
        x = -40 + (i / 100) * 80  # x from -40 to 40
        y = (40**2 - x**2)**0.5  # Calculate y from circle equation
        restricted_arc_x.append(x)
        restricted_arc_y.append(y)
    fig.add_trace(
        go.Scatter(
            x=restricted_arc_x,
            y=restricted_arc_y,
            mode="lines",
            line=dict(color="black", width=2),
            showlegend=False,
            hoverinfo="skip",
        )
    )

    # 6. Free Throw Circle (Top of Key) - Radius 6ft = 60 units. Center at (0, 142.5)
    # Top half (solid)
    free_throw_top_x = []
    free_throw_top_y = []
    for i in range(101):
        angle = np.pi + (i / 100) * np.pi  # 180 to 360 degrees (top half)
        free_throw_top_x.append(60 * np.cos(angle))
        free_throw_top_y.append(142.5 + 60 * np.sin(angle))
    fig.add_trace(
        go.Scatter(
            x=free_throw_top_x,
            y=free_throw_top_y,
            mode="lines",
            line=dict(color="black", width=2),
            showlegend=False,
            hoverinfo="skip",
        )
    )
    # Bottom half (dashed)
    free_throw_bottom_x = []
    free_throw_bottom_y = []
    for i in range(101):
        angle = 0 + (i / 100) * np.pi  # 0 to 180 degrees (bottom half)
        free_throw_bottom_x.append(60 * np.cos(angle))
        free_throw_bottom_y.append(142.5 + 60 * np.sin(angle))
    fig.add_trace(
        go.Scatter(
            x=free_throw_bottom_x,
            y=free_throw_bottom_y,
            mode="lines",
            line=dict(color="black", width=2, dash="dash"),
            showlegend=False,
            hoverinfo="skip",
        )
    )

    # 7. Three Point Line (Complex Geometry)
    # Straight lines: 22ft from center. Length 14ft = 140 units from baseline
    corner_y = -47.5 + 140  # 14ft from baseline
    court_shapes.append(dict(type="line", x0=-220, y0=-47.5, x1=-220, y1=corner_y, line=dict(color="black", width=2)))
    court_shapes.append(dict(type="line", x0=220, y0=-47.5, x1=220, y1=corner_y, line=dict(color="black", width=2)))
    # Arc: Radius 23.75ft = 237.5 units. Center (0,0).
    three_pt_arc_x = []
    three_pt_arc_y = []
    for i in range(201):
        x = -220 + (i / 200) * 440  # x from -220 to 220
        if abs(x) <= 237.5:
            y = (237.5**2 - x**2)**0.5
            if y >= corner_y:  # Only above where straight lines end
                three_pt_arc_x.append(x)
                three_pt_arc_y.append(y)
    fig.add_trace(
        go.Scatter(
            x=three_pt_arc_x,
            y=three_pt_arc_y,
            mode="lines",
            line=dict(color="black", width=2),
            showlegend=False,
            hoverinfo="skip",
        )
    )

    # 8. Center Circle (Half)
    center_circle_x = []
    center_circle_y = []
    for i in range(101):
        angle = 0 + (i / 100) * np.pi  # 0 to 180 degrees (half circle)
        center_circle_x.append(60 * np.cos(angle))
        center_circle_y.append(422.5 + 60 * np.sin(angle))
    fig.add_trace(
        go.Scatter(
            x=center_circle_x,
            y=center_circle_y,
            mode="lines",
            line=dict(color="black", width=2),
            showlegend=False,
            hoverinfo="skip",
        )
    )

    # Update Layout
    fig.update_layout(
        shapes=court_shapes,
        xaxis=dict(range=[-250, 250], showgrid=False, zeroline=False, showticklabels=False, visible=False),
        yaxis=dict(range=[-47.5, 422.5], scaleanchor="x", scaleratio=1, showgrid=False, zeroline=False, showticklabels=False, visible=False),
        plot_bgcolor="#f8f8f8",  # Clean Cream/White background (Like the Curry example)
        paper_bgcolor="white",
        width=600, height=564,
        margin=dict(l=0, r=0, t=0, b=0)
    )
    return fig


def create_hexbin_heatmap(shot_df: pd.DataFrame, hex_size: float = 30.0) -> list:
    """
    Create hexagonal bins for shot frequency heatmap.
    Returns a list of dictionaries with hexagon coordinates and shot frequency.
    """
    if shot_df.empty or "LOC_X" not in shot_df.columns or "LOC_Y" not in shot_df.columns:
        return []
    
    # Filter valid shots
    valid_shots = shot_df.dropna(subset=["LOC_X", "LOC_Y"])
    if valid_shots.empty:
        return []
    
    x_coords = valid_shots["LOC_X"].values
    y_coords = valid_shots["LOC_Y"].values
    
    # Create hexagon grid
    # Hex size controls the bin size
    hex_bins = []
    
    # Calculate hexagon grid bounds
    x_min, x_max = x_coords.min(), x_coords.max()
    y_min, y_max = y_coords.min(), y_coords.max()
    
    # Expand bounds slightly
    x_min -= hex_size
    x_max += hex_size
    y_min -= hex_size
    y_max += hex_size
    
    # Create grid of hexagon centers
    # Hexagon spacing: horizontal = hex_size * sqrt(3), vertical = hex_size * 1.5
    h_spacing = hex_size * np.sqrt(3)
    v_spacing = hex_size * 1.5
    
    x_centers = np.arange(x_min, x_max + h_spacing, h_spacing)
    y_centers = np.arange(y_min, y_max + v_spacing, v_spacing)
    
    # Count shots in each hexagon
    for i, y_center in enumerate(y_centers):
        for j, x_center in enumerate(x_centers):
            # Offset every other row for hexagonal packing
            x_offset = (h_spacing / 2) if (i % 2 == 1) else 0
            x_center_actual = x_center + x_offset
            
            # Calculate distance from hexagon center to each shot
            distances = np.sqrt((x_coords - x_center_actual)**2 + (y_coords - y_center)**2)
            shots_in_bin = np.sum(distances <= hex_size)
            
            if shots_in_bin > 0:
                # Create hexagon vertices (6 points)
                hex_vertices_x = []
                hex_vertices_y = []
                for k in range(6):
                    angle = (k * np.pi) / 3  # 60 degrees per vertex
                    hex_vertices_x.append(x_center_actual + hex_size * np.cos(angle))
                    hex_vertices_y.append(y_center + hex_size * np.sin(angle))
                
                # Close the hexagon
                hex_vertices_x.append(hex_vertices_x[0])
                hex_vertices_y.append(hex_vertices_y[0])
                
                hex_bins.append({
                    "x": hex_vertices_x,
                    "y": hex_vertices_y,
                    "count": int(shots_in_bin),
                    "center_x": x_center_actual,
                    "center_y": y_center,
                })
    
    return hex_bins


# -----------------------------
# Sidebar & About Me
# -----------------------------
def sidebar_header() -> None:
    st.sidebar.markdown(
        """
        <div style="display:flex; flex-direction:column; align-items:center; gap:12px;">
            <div style="
                width:120px; height:120px; border-radius:60px;
                background: linear-gradient(135deg, #1f77b4, #2ca02c);
                display:flex; align-items:center; justify-content:center;
                color:white; font-weight:700; font-size:26px;
            ">
                DA
            </div>
            <div style="text-align:center;">
                <h3 style="margin:0;">Deni Avdija</h3>
                <p style="margin:0; color:#6c757d;">360Â° Performance Analytics</p>
            </div>
        </div>
        """,
        unsafe_allow_html=True,
    )


def about_me_page() -> None:
    st.subheader("About Me")
    col1, col2 = st.columns([1, 2])
    with col1:
        st.markdown(
            """
            <div style="
                width:160px; height:160px; border-radius:80px;
                background: linear-gradient(135deg, #1f77b4, #2ca02c);
                display:flex; align-items:center; justify-content:center;
                color:white; font-weight:800; font-size:32px;
                box-shadow:0 4px 12px rgba(0,0,0,0.15);
            ">
                RS
            </div>
            """,
            unsafe_allow_html=True,
        )
    with col2:
        st.markdown("### Ram Shiri")
        st.write(
            "Third-year B.Sc. Data Engineering student specializing in data science with a passion "
            "for building smart, practical solutions. Skilled in Python, Java, SQL, and modern tools "
            "like Pandas. Known for creative thinking, fast learning, and a hands-on approach to "
            "problem solving."
        )
        st.write(
            "Comfortable working with and without AI tools, and excited about using technology to "
            "drive real-world impact â€” especially in the world of sports."
        )
        
        st.markdown("### Education")
        st.write("**Ben-Gurion University of the Negev** (2022-2025)")
        st.write("B.Sc. in Data Engineering | Third Year")
        st.write("Relevant Courses: Python Programming, Data Structures, Probability & Statistics, Data Engineering and Big Data")
        
        st.markdown("### Skills")
        st.write("**Technical:** Python â€¢ Java â€¢ SQL â€¢ Pandas â€¢ Data Visualization (Plotly, Streamlit)")
        st.write("**Languages:** Hebrew (Native) â€¢ English (Proficient)")
        
        st.markdown("### Experience")
        st.write("**Epidemiological Investigator** â€“ Ministry of Health (2020-2021)")
        st.write("â€¢ Conducted case investigations and data analysis for COVID-19 patients")
        st.write("â€¢ Completed official epidemiology training and infectious disease control certification")
        
        st.write("**IDF Service** (2017-2020) | **Reserve Duty** (2023-2025)")
        st.write("â€¢ Operational and research roles with focus on analytical capacity")
        
        st.markdown("### Contact")
        st.write("ðŸ“§ Email: RamShi@gmail.com")
        st.write("ðŸ“± Phone: 052-6299701")
        st.write("ðŸ’¼ LinkedIn: [Ram Shiri](https://www.linkedin.com/in/ram-shiri)")
        st.write("ðŸ’» GitHub: [github.com/ramshiri](https://github.com/ramshiri)")
        
        st.markdown("---")
        st.write("**Actively seeking** a student or full-time position in software or data engineering to grow, contribute, and thrive in a dynamic, purpose-driven environment.")


# -----------------------------
# Layout & page selection
# -----------------------------
sidebar_header()
page = st.sidebar.radio(
    "Navigate",
    ["Dashboard", "Detailed Analysis", "Raw Data", "Shot Maps", "Research: Deep Dive", "About Me"],
)

# Load data from pickle file
nba_data = load_nba_data()

# Check if data file exists
if not nba_data:
    st.error(f"âš ï¸ **Data file not found.** Please run `python fetch_data.py` first to generate `{DATA_FILE}`.")
    st.info("ðŸ’¡ Once you've run `fetch_data.py`, refresh this page to load the data.")
    st.stop()

# Extract data from dictionary
career_basic_df = nba_data.get("career_basic", pd.DataFrame())
career_adv_df = nba_data.get("career_advanced", pd.DataFrame())
logs_df = nba_data.get("game_logs_2025_26", pd.DataFrame())
logs_df_24_25 = nba_data.get("game_logs_2024_25", pd.DataFrame())
shot_charts_dict = nba_data.get("shot_charts", {})
allstar_df = nba_data.get("allstar_stats", pd.DataFrame())
allstar_detailed_df = nba_data.get("allstar_detailed_stats", pd.DataFrame())

# Merge career data
career_df = merge_career_frames(career_basic_df, career_adv_df)

# Display data info in sidebar
st.sidebar.markdown("---")
st.sidebar.caption("Data via nba_api â€¢ Plots via Plotly â€¢ Loaded from local file")
last_updated = get_file_mod_time()
if last_updated != "N/A":
    fetched_at = nba_data.get("fetched_at", "")
    if fetched_at:
        try:
            fetched_dt = datetime.fromisoformat(fetched_at)
            fetched_str = fetched_dt.strftime("%Y-%m-%d %H:%M:%S")
            st.sidebar.info(f"ðŸ“… **Last Updated:** {fetched_str}")
        except Exception:
            st.sidebar.info(f"ðŸ“… **Last Updated:** {last_updated}")
    else:
        st.sidebar.info(f"ðŸ“… **Last Updated:** {last_updated}")


# -----------------------------
# Pages
# -----------------------------
st.title("Deni Avdija: 360Â° Performance Analytics")
st.write(
    "Tracking scoring, rebounding, playmaking, efficiency, and current-season impact "
    "to give a complete scouting read on Deni Avdija."
)

if page == "Dashboard":
    # Dashboard now shows Detailed Analysis content
    st.subheader("Career Trends")
    if career_df.empty:
        st.warning("No career data returned yet. Try again shortly.")
    else:
        st.plotly_chart(plot_per_game_stats(career_df), use_container_width=True)
        st.plotly_chart(plot_per_36_stats(career_df), use_container_width=True)
        
        c1, c2 = st.columns(2)
        with c1:
            st.plotly_chart(plot_usage_growth(career_df), use_container_width=True)
        with c2:
            st.plotly_chart(plot_ts_growth(career_df), use_container_width=True)

    st.subheader("Season Deep Dive")
    col1, col2 = st.columns(2)
    with col1:
        st.markdown(f"#### {CURRENT_SEASON}")
    if logs_df.empty:
        st.info(f"No {CURRENT_SEASON} game logs yet.")
    else:
        st.plotly_chart(plot_current_season(logs_df, CURRENT_SEASON), use_container_width=True)
    with col2:
        st.markdown("#### 2024-25")
        if logs_df_24_25.empty:
            st.info("No 2024-25 game logs yet.")
        else:
            st.plotly_chart(plot_current_season(logs_df_24_25, "2024-25"), use_container_width=True)

elif page == "Detailed Analysis":
    st.subheader("Career Trends")
    if career_df.empty:
        st.warning("No career data returned yet. Try again shortly.")
    else:
        st.plotly_chart(plot_per_game_stats(career_df), use_container_width=True)
        st.plotly_chart(plot_per_36_stats(career_df), use_container_width=True)
        
        c1, c2 = st.columns(2)
        with c1:
            st.plotly_chart(plot_usage_growth(career_df), use_container_width=True)
        with c2:
            st.plotly_chart(plot_ts_growth(career_df), use_container_width=True)

    st.subheader("Season Deep Dive")
    col1, col2 = st.columns(2)
    with col1:
        st.markdown(f"#### {CURRENT_SEASON}")
    if logs_df.empty:
        st.info(f"No {CURRENT_SEASON} game logs yet.")
    else:
            st.plotly_chart(plot_current_season(logs_df, CURRENT_SEASON), use_container_width=True)
    with col2:
        st.markdown("#### 2024-25")
        if logs_df_24_25.empty:
            st.info("No 2024-25 game logs yet.")
        else:
            st.plotly_chart(plot_current_season(logs_df_24_25, "2024-25"), use_container_width=True)

elif page == "Raw Data":
    st.subheader("Master Career Data")
    
    if career_df.empty:
        st.warning("No career data available.")
    else:
        # Column renaming mapping
        column_mapping = {
            "SEASON_ID": "Season",
            "PTS": "Points",
            "REB": "Rebounds",
            "AST": "Assists",
            "GP": "Games",
            "MIN": "Minutes",
            "FG_PCT": "FG%",
            "FG3_PCT": "3P%",
            "FT_PCT": "FT%",
            "USG_PCT": "Usage",
            "TS_PCT": "True Shooting",
            "NET_RATING": "Net Rating",
            "AST_TO": "AST/TO",
        }
        
        # Create display dataframe with renamed columns
        display_df = career_df.copy()
        
        # Drop unwanted columns
        columns_to_drop = ["PLAYER_ID", "LEAGUE_ID", "TEAM_ID", "Team_ID"]
        for col in columns_to_drop:
            if col in display_df.columns:
                display_df = display_df.drop(columns=[col])
        
        display_df = display_df.rename(columns=column_mapping)
        
        # Multi-Trend Viewer (before formatting percentages)
        st.markdown("### ðŸ“Š Multi-Trend Viewer: Select metrics to compare over seasons")
        
        # Get available numeric metrics for selection (use original column names)
        numeric_metrics = []
        metric_mapping = {}  # Maps display name to original column name in career_df
        
        # Build list of available numeric metrics
        if "PTS" in career_df.columns:
            numeric_metrics.append("Points")
            metric_mapping["Points"] = "PTS"
        if "REB" in career_df.columns:
            numeric_metrics.append("Rebounds")
            metric_mapping["Rebounds"] = "REB"
        if "AST" in career_df.columns:
            numeric_metrics.append("Assists")
            metric_mapping["Assists"] = "AST"
        if "MIN" in career_df.columns:
            numeric_metrics.append("Minutes")
            metric_mapping["Minutes"] = "MIN"
        if "NET_RATING" in career_df.columns:
            numeric_metrics.append("Net Rating")
            metric_mapping["Net Rating"] = "NET_RATING"
        if "AST_TO" in career_df.columns:
            numeric_metrics.append("AST/TO")
            metric_mapping["AST/TO"] = "AST_TO"
        if "USG_PCT" in career_df.columns:
            numeric_metrics.append("Usage")
            metric_mapping["Usage"] = "USG_PCT"
        if "TS_PCT" in career_df.columns:
            numeric_metrics.append("True Shooting")
            metric_mapping["True Shooting"] = "TS_PCT"
        
        if numeric_metrics and "SEASON_ID" in career_df.columns:
            selected_metrics = st.multiselect(
                "Select Metrics",
                numeric_metrics,
                default=["Points"] if "Points" in numeric_metrics else [numeric_metrics[0]] if numeric_metrics else [],
            )
            
            if selected_metrics:
                # Create trend dataframe from original career_df
                trend_df = career_df[["SEASON_ID"]].copy()
                trend_df.columns = ["Season"]
                
                # Add selected metrics (convert percentages to percentage points)
                for metric_display in selected_metrics:
                    orig_col = metric_mapping[metric_display]
                    if orig_col in career_df.columns:
                        values = career_df[orig_col].copy()
                        # Convert percentage columns to percentage points (0.45 -> 45)
                        if "PCT" in orig_col or "USG" in orig_col:
                            values = values * 100
                        trend_df[metric_display] = values
                
                # Create multi-line chart
                fig = px.line(
                    trend_df,
                    x="Season",
                    y=selected_metrics,
                    title="Career Trends: Multiple Metrics Comparison",
                    markers=True,
                )
                fig.update_layout(
                    xaxis_title="Season",
                    yaxis_title="Value",
                    hovermode="x unified",
                    legend=dict(title="Metrics"),
                )
                st.plotly_chart(fig, use_container_width=True)
        
        # Now format percentage columns for display
        percentage_cols = ["FG%", "3P%", "FT%"]
        for col in percentage_cols:
            if col in display_df.columns:
                display_df[col] = (display_df[col] * 100).round(1).astype(str) + "%"
        
        # Format Usage and True Shooting as percentages
        if "Usage" in display_df.columns:
            display_df["Usage"] = (display_df["Usage"] * 100).round(1).astype(str) + "%"
        if "True Shooting" in display_df.columns:
            display_df["True Shooting"] = (display_df["True Shooting"] * 100).round(1).astype(str) + "%"
        
        # Display master table
        st.markdown("### Career Statistics Table")
        st.dataframe(display_df, use_container_width=True, hide_index=True)

elif page == "Shot Maps":
    st.subheader("Shot Maps")
    season = st.selectbox("Select Season", ["2022-23", "2023-24", "2024-25", "2025-26"], index=3)
    
    # Heatmap toggle
    show_heatmap = st.checkbox("Show Heatmap", value=True)
    
    # Load shot data from dictionary
    shot_df = shot_charts_dict.get(season, pd.DataFrame())
    
    if shot_df.empty:
        st.warning(f"No shot data available for {season}.")
    else:
        # Create court figure
        fig = draw_nba_court()
        
        # Filter out shots with missing location data
        shot_df_clean = shot_df.dropna(subset=["LOC_X", "LOC_Y"])
        
        if shot_df_clean.empty:
            st.warning("No shot location data available.")
        else:
            # Separate made and missed shots
            made_shots = shot_df_clean[shot_df_clean["EVENT_TYPE"] == "Made Shot"]
            missed_shots = shot_df_clean[shot_df_clean["EVENT_TYPE"] == "Missed Shot"]
            
            # Hexagonal heatmap overlay (if enabled)
            max_freq = 0
            if show_heatmap:
                hex_bins = create_hexbin_heatmap(shot_df_clean, hex_size=30.0)
                
                if hex_bins:
                    # Calculate max frequency for color scaling
                    max_freq = max(bin_data["count"] for bin_data in hex_bins)
                    
                    # Add each hexagon as a filled polygon with gist_heat_r color scheme
                    for bin_data in hex_bins:
                        # Color intensity based on shot frequency
                        # Normalize frequency to 0-1 range
                        intensity = bin_data["count"] / max_freq if max_freq > 0 else 0
                        
                        # gist_heat_r colormap: Dark red/black (high) -> Orange -> Yellow -> White (low)
                        if intensity < 0.2:
                            # White to light yellow
                            t = intensity / 0.2
                            r = int(255)
                            g = int(255 - t * 50)  # 255 to 205
                            b = int(220 - t * 100)  # 220 to 120
                        elif intensity < 0.4:
                            # Light yellow to yellow-orange
                            t = (intensity - 0.2) / 0.2
                            r = int(255)
                            g = int(205 - t * 85)  # 205 to 120
                            b = int(120 - t * 120)  # 120 to 0
                        elif intensity < 0.6:
                            # Orange to red-orange
                            t = (intensity - 0.4) / 0.2
                            r = int(255)
                            g = int(120 - t * 50)  # 120 to 70
                            b = 0
                        elif intensity < 0.8:
                            # Red-orange to red
                            t = (intensity - 0.6) / 0.2
                            r = int(255)
                            g = int(70 - t * 50)  # 70 to 20
                            b = 0
                        else:
                            # Red to dark red/black
                            t = (intensity - 0.8) / 0.2
                            r = int(255 - t * 120)  # 255 to 135
                            g = int(20 - t * 20)  # 20 to 0
                            b = 0
                        
                        # Semi-transparent for visibility
                        color = f"rgba({r}, {g}, {b}, 0.7)"
                        
                        fig.add_trace(
                            go.Scatter(
                                x=bin_data["x"],
                                y=bin_data["y"],
                                mode="lines",
                                fill="toself",
                                fillcolor=color,
                                line=dict(color=color, width=0.5),
                                showlegend=False,
                                hoverinfo="skip",
                            )
                        )
                
                # Add colorbar (only if heatmap is shown and we have bins)
                if hex_bins and max_freq > 0:
                    # Create colorbar using a completely invisible trace
                    # Use a point outside visible range and make it invisible
                    fig.add_trace(
                        go.Scatter(
                            x=[500],  # Way outside visible range
                            y=[500],
                            mode="markers",
                            marker=dict(
                                size=0.01,  # Tiny size
                                opacity=0,  # Completely transparent
                                cmin=0,
                                cmax=max_freq,
                                colorscale=[[0, 'rgba(255, 255, 255, 0.7)'],
                                            [0.2, 'rgba(255, 255, 220, 0.7)'],
                                            [0.4, 'rgba(255, 200, 100, 0.7)'],
                                            [0.6, 'rgba(255, 150, 50, 0.7)'],
                                            [0.8, 'rgba(255, 80, 0, 0.7)'],
                                            [1.0, 'rgba(200, 0, 0, 0.7)']],
                                showscale=True,
                                color=[max_freq],
                                colorbar=dict(
                                    title=dict(text="Shot Frequency", font=dict(size=12, color="black")),
                                    tickfont=dict(size=10, color="black"),
                                    len=0.4,
                                    y=0.25,
                                    x=1.08,
                                    bgcolor="rgba(255, 255, 255, 0.9)",
                                    bordercolor="black",
                                    borderwidth=2,
                                    thickness=15,
                                ),
                            ),
                            showlegend=False,
                            hoverinfo="skip",
                        )
                    )
            
            # Add made shots (green circles "o") - ON TOP of heatmap
            if not made_shots.empty:
                fig.add_trace(
                    go.Scatter(
                        x=made_shots["LOC_X"],
                        y=made_shots["LOC_Y"],
                        mode="markers",
                        name="Made Shot",
                        marker=dict(
                            color="green",
                            size=5,
                            symbol="circle",
                            line=dict(width=1, color="darkgreen"),
                            opacity=0.8,
                        ),
                        hovertemplate="Made Shot<br>X: %{x:.1f}<br>Y: %{y:.1f}<extra></extra>",
                    )
                )
            
            # Add missed shots (red X markers) - ON TOP of heatmap
            if not missed_shots.empty:
                fig.add_trace(
                    go.Scatter(
                        x=missed_shots["LOC_X"],
                        y=missed_shots["LOC_Y"],
                        mode="markers",
                        name="Missed Shot",
                        marker=dict(
                            color="red",
                            size=5,
                            symbol="x",
                            line=dict(width=1.5, color="darkred"),
                            opacity=0.8,
                        ),
                        hovertemplate="Missed Shot<br>X: %{x:.1f}<br>Y: %{y:.1f}<extra></extra>",
                    )
                )
            
            # Update title
            fig.update_layout(
                title=f"Shot Chart - {season}",
                showlegend=True,
            )
            
            st.plotly_chart(fig, use_container_width=True)

elif page == "Research: Deep Dive":
    st.subheader("Research: Deep Dive Analysis")
    
    # All-Star Threshold Section
    st.markdown("### The All-Star Threshold")
    st.write("Comparing Deni's 2025-26 performance against the weighted average of 2024 NBA All-Stars (2024-25 season stats) and the 'Entry Level' All-Stars (bottom 4 scorers).")
    
    # Get Deni's current season stats - improved fallback logic
    deni_stats = {}
    deni_advanced_stats = {}
    
    # Try to get Deni's 2025-26 stats from career data first
    if not career_df.empty:
        deni_current = career_df[career_df["SEASON_ID"] == "2025-26"]
        if not deni_current.empty:
            deni_stats = {
                "PTS": round(deni_current.iloc[0].get("PTS", 0), 1),
                "REB": round(deni_current.iloc[0].get("REB", 0), 1),
                "AST": round(deni_current.iloc[0].get("AST", 0), 1),
            }
            deni_advanced_stats = {
                "USG_PCT": round(deni_current.iloc[0].get("USG_PCT", 0), 3),
                "TS_PCT": round(deni_current.iloc[0].get("TS_PCT", 0), 3),
            }
    
    # If not found, calculate from game logs
    if not deni_stats and not logs_df.empty:
        if "PTS" in logs_df.columns and len(logs_df) > 0:
            deni_stats = {
                "PTS": round(logs_df["PTS"].mean(), 1),
                "REB": round(logs_df["REB"].mean() if "REB" in logs_df.columns else 0, 1),
                "AST": round(logs_df["AST"].mean() if "AST" in logs_df.columns else 0, 1),
            }
    
    # Final fallback to most recent season from career data
    if not deni_stats and not career_df.empty:
        latest_season = career_df.iloc[-1]
        deni_stats = {
            "PTS": round(latest_season.get("PTS", 0), 1),
            "REB": round(latest_season.get("REB", 0), 1),
            "AST": round(latest_season.get("AST", 0), 1),
        }
        deni_advanced_stats = {
            "USG_PCT": round(latest_season.get("USG_PCT", 0), 3),
            "TS_PCT": round(latest_season.get("TS_PCT", 0), 3),
        }
    
    # Merge advanced stats into deni_stats
    deni_stats.update(deni_advanced_stats)
    
    # Show status messages and ensure we always have data
    if allstar_df.empty:
        st.error("âŒ Could not load All-Star comparison data from file.")
        st.info("ðŸ’¡ **Troubleshooting:**")
        st.write("- Please run `python fetch_data.py` to regenerate the data file")
        st.write("- Check that the All-Star data was fetched successfully")
    else:
        # Ensure we have Deni stats
        if not deni_stats:
            st.warning("âš ï¸ Could not fetch Deni's current season stats for comparison.")
            st.info("ðŸ’¡ Using most recent available season data as fallback.")
            deni_stats = {"PTS": 0.0, "REB": 0.0, "AST": 0.0}
        
        # Display All-Star Comparison Chart
        try:
            comparison_fig, stats, bottom_4_df = plot_allstar_comparison(deni_stats, allstar_df)
            st.plotly_chart(comparison_fig, use_container_width=True)
            
            # Full Comparison Table with Deni
            st.markdown("### Full Comparison Table")
            
            # Add sort selector
            sort_by = st.selectbox("Sort by:", ["Points", "Rebounds", "Assists"], index=0, key="sort_selector")
            
            # Prepare comparison dataframe with all All-Stars + Deni
            comparison_df = allstar_df[["PLAYER_NAME", "GP", "PTS", "REB", "AST"]].copy()
            # Round All-Star stats to 1 decimal (ensure proper float format)
            comparison_df["PTS"] = comparison_df["PTS"].round(1)
            comparison_df["REB"] = comparison_df["REB"].round(1)
            comparison_df["AST"] = comparison_df["AST"].round(1)
            # Rename columns to clean names
            comparison_df.columns = ["Player", "GP", "Points", "Rebounds", "Assists"]
            
            # Add Deni's row (round to 1 decimal)
            deni_row = pd.DataFrame({
                "Player": ["Deni Avdija (2025-26)"],
                "GP": [logs_df.shape[0] if not logs_df.empty else 0],
                "Points": [round(deni_stats["PTS"], 1)],
                "Rebounds": [round(deni_stats["REB"], 1)],
                "Assists": [round(deni_stats["AST"], 1)],
            })
            comparison_df = pd.concat([comparison_df, deni_row], ignore_index=True)
            
            # Sort by selected column for display FIRST
            comparison_df = comparison_df.sort_values(sort_by, ascending=False).reset_index(drop=True)
            
            # Calculate rank as sequential numbers based on sorted order (1 = best/highest)
            # This ensures ranks are sequential: 1, 2, 3, 4...
            comparison_df["Rank"] = range(1, len(comparison_df) + 1)
            
            # Reorder columns: rank first, then player info, then stats
            comparison_df = comparison_df[["Rank", "Player", "GP", "Points", "Rebounds", "Assists"]]
            
            # Apply yellow highlighting to Deni's row (before formatting)
            def highlight_deni(row):
                if "Deni Avdija" in str(row["Player"]):
                    return ["background-color: yellow"] * len(row)
                return [""] * len(row)
            
            styled_df = comparison_df.style.apply(highlight_deni, axis=1)
            
            # Format numbers using column_config to preserve numeric sorting
            column_config = {
                "Rank": st.column_config.NumberColumn(
                    "Rank",
                    format="%d",
                ),
                "Points": st.column_config.NumberColumn(
                    "Points",
                    format="%.1f",
                ),
                "Rebounds": st.column_config.NumberColumn(
                    "Rebounds",
                    format="%.1f",
                ),
                "Assists": st.column_config.NumberColumn(
                    "Assists",
                    format="%.1f",
                ),
            }
            
            st.dataframe(styled_df, use_container_width=True, hide_index=True, column_config=column_config)
            
            # Data Source Expander (All-Stars only, sorted)
            with st.expander("ðŸ“‹ All-Star Data Source (2024-25 Stats)", expanded=False):
                source_df = allstar_df[["PLAYER_NAME", "GP", "PTS", "REB", "AST"]].copy()
                # Round to 1 decimal before renaming
                source_df["PTS"] = source_df["PTS"].round(1)
                source_df["REB"] = source_df["REB"].round(1)
                source_df["AST"] = source_df["AST"].round(1)
                # Rename to clean column names
                source_df.columns = ["Player", "GP", "Points", "Rebounds", "Assists"]
                source_df = source_df.sort_values("Points", ascending=False)
                
                # Add weighted average row (keep as numeric)
                total_gp = allstar_df["GP"].sum()
                weighted_row = pd.DataFrame({
                    "Player": ["**Weighted Average**"],
                    "GP": [int(total_gp)],
                    "Points": [stats['allstar_pts']],
                    "Rebounds": [stats['allstar_reb']],
                    "Assists": [stats['allstar_ast']],
                })
                source_df = pd.concat([source_df, weighted_row], ignore_index=True)
                
                # Format numbers using column_config to preserve numeric sorting
                column_config = {
                    "Points": st.column_config.NumberColumn(
                        "Points",
                        format="%.1f",
                    ),
                    "Rebounds": st.column_config.NumberColumn(
                        "Rebounds",
                        format="%.1f",
                    ),
                    "Assists": st.column_config.NumberColumn(
                        "Assists",
                        format="%.1f",
                    ),
                }
                
                st.dataframe(source_df, use_container_width=True, hide_index=True, column_config=column_config)
            
            # The Analytical Verdict - Dynamic Narrative Engine
            if stats and not allstar_df.empty:
                pts_delta = round(stats["deni_pts"] - stats["allstar_pts"], 1)
                reb_delta = round(stats["deni_reb"] - stats["allstar_reb"], 1)
                ast_delta = round(stats["deni_ast"] - stats["allstar_ast"], 1)
                
                # Calculate percentile rankings
                def calculate_percentile(deni_value, allstar_values):
                    """Calculate what percentile Deni ranks in among All-Stars."""
                    better_count = sum(allstar_values >= deni_value)
                    total = len(allstar_values)
                    percentile = (total - better_count) / total * 100
                    return percentile
                
                pts_percentile = calculate_percentile(stats["deni_pts"], allstar_df["PTS"])
                reb_percentile = calculate_percentile(stats["deni_reb"], allstar_df["REB"])
                ast_percentile = calculate_percentile(stats["deni_ast"], allstar_df["AST"])
                
                st.markdown("---")
                st.markdown("## ðŸŽ¯ The Analytical Verdict")
                
                # Display metrics side-by-side with deltas
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    delta_color = "normal" if pts_delta > 0 else "inverse"
                    st.metric(
                        label="Points Per Game",
                        value=f"{stats['deni_pts']:.1f}",
                        delta=f"{pts_delta:+.1f} vs All-Star Avg",
                        delta_color=delta_color,
                        help=f"Deni ranks in the {pts_percentile:.0f}th percentile among All-Stars in scoring",
                    )
                
                with col2:
                    delta_color = "normal" if reb_delta > 0 else "inverse"
                    st.metric(
                        label="Rebounds Per Game",
                        value=f"{stats['deni_reb']:.1f}",
                        delta=f"{reb_delta:+.1f} vs All-Star Avg",
                        delta_color=delta_color,
                        help=f"Deni ranks in the {reb_percentile:.0f}th percentile among All-Stars in rebounding",
                    )
                
                with col3:
                    delta_color = "normal" if ast_delta > 0 else "inverse"
                    st.metric(
                        label="Assists Per Game",
                        value=f"{stats['deni_ast']:.1f}",
                        delta=f"{ast_delta:+.1f} vs All-Star Avg",
                        delta_color=delta_color,
                        help=f"Deni ranks in the {ast_percentile:.0f}th percentile among All-Stars in playmaking",
                    )
                
                # Dynamic Narrative Generation
                st.markdown("### ðŸ“Š The Data-Driven Case")
                
                narrative_paragraphs = []
                
                # Scoring narrative
                if pts_delta > 0:
                    narrative_paragraphs.append(
                        f"**Elite Scoring Output**: Deni's {stats['deni_pts']:.1f} points per game places him **{pts_delta:+.1f}** above the All-Star average, "
                        f"ranking in the **{pts_percentile:.0f}th percentile** of All-Star scorers. This represents a significant leap in offensive production, "
                        "demonstrating he can carry the scoring load at the highest level. His ability to score efficiently while maintaining playmaking "
                        "and rebounding duties showcases a rare, complete offensive game."
                    )
                elif pts_delta > -2:
                    narrative_paragraphs.append(
                        f"**Solid Scoring Production**: Deni's {stats['deni_pts']:.1f} points per game is within {abs(pts_delta):.1f} of the All-Star average, "
                        f"placing him in the **{pts_percentile:.0f}th percentile**. While not elite in volume, his scoring efficiency and versatility "
                        "make him a valuable offensive weapon. His ability to score from multiple levels while facilitating creates matchup problems for defenses."
                    )
                else:
                    narrative_paragraphs.append(
                        f"**Scoring Development**: At {stats['deni_pts']:.1f} points per game, Deni is {abs(pts_delta):.1f} below the All-Star average. "
                        "However, his strength lies in his all-around game and efficiency rather than pure volume scoring. As he continues to develop "
                        "his offensive aggression, there's clear upside in this category."
                    )
                
                # Playmaking narrative
                if ast_delta > 0:
                    narrative_paragraphs.append(
                        f"**Point-Forward Evolution**: Deni's {stats['deni_ast']:.1f} assists per game exceeds the All-Star average by **{ast_delta:+.1f}**, "
                        f"placing him in the **{ast_percentile:.0f}th percentile** of All-Star playmakers. This elite passing ability at his size (6'9\") "
                        "creates a unique advantage, allowing him to initiate offense and create for teammates. His vision and decision-making elevate "
                        "the entire offense, making him a true offensive engine."
                    )
                elif ast_delta > -1:
                    narrative_paragraphs.append(
                        f"**Strong Playmaking Impact**: With {stats['deni_ast']:.1f} assists per game, Deni demonstrates solid playmaking chops, "
                        f"ranking in the **{ast_percentile:.0f}th percentile** among All-Stars. His ability to create for others at his size "
                        "adds a valuable dimension to his game, allowing him to operate as a secondary playmaker and create mismatches."
                    )
                else:
                    narrative_paragraphs.append(
                        f"**Playmaking Potential**: Deni's assist numbers show room for growth, but his court vision and passing ability are evident. "
                        "As his usage rate increases and he takes on more playmaking responsibilities, this metric should trend upward."
                    )
                
                # Rebounding narrative
                if reb_delta > 0:
                    narrative_paragraphs.append(
                        f"**Two-Way Impact**: Deni's {stats['deni_reb']:.1f} rebounds per game exceeds the All-Star average by **{reb_delta:+.1f}**, "
                        f"placing him in the **{reb_percentile:.0f}th percentile**. This elite rebounding for a wing player demonstrates his commitment "
                        "to both ends of the floor. His ability to clean the glass and immediately push the tempo creates transition opportunities "
                        "and adds another layer to his value proposition."
                    )
                elif reb_delta > -1:
                    narrative_paragraphs.append(
                        f"**Versatile Rebounding**: Deni's {stats['deni_reb']:.1f} rebounds per game shows solid activity on the glass, "
                        f"ranking in the **{reb_percentile:.0f}th percentile** among All-Stars. His rebounding ability, combined with his ball-handling "
                        "and passing, allows him to grab and go, creating fast-break opportunities that maximize his skill set."
                    )
                else:
                    narrative_paragraphs.append(
                        f"**Rebounding Context**: While Deni's rebounding numbers are below the All-Star average, his value comes from his ability "
                        "to rebound in traffic and immediately initiate offense. His unique combination of size and skill creates rebounding "
                        "opportunities in transition and on the perimeter."
                    )
                
                # Display narrative paragraphs
                for para in narrative_paragraphs:
                    st.write(para)
                    st.write("")  # Spacing
                
                # Final Verdict Box
                metrics_above = sum([pts_delta > 0, reb_delta > 0, ast_delta > 0])
                avg_percentile = (pts_percentile + reb_percentile + ast_percentile) / 3
                
                st.markdown("---")
                
                if metrics_above >= 2 or avg_percentile >= 60:
                    st.success(
                        f"ðŸ† **ALL-STAR CALIBER**: Deni exceeds All-Star averages in {metrics_above} of 3 key categories with an average "
                        f"percentile rank of {avg_percentile:.0f}th. His complete skill set, elite production in multiple areas, and unique "
                        f"combination of size and versatility make a compelling case for All-Star recognition. He's not just meeting the standardâ€”"
                        f"he's redefining what a modern wing can contribute across the board."
                    )
                elif metrics_above == 1 or avg_percentile >= 45:
                    st.warning(
                        f"âš¡ **BORDERLINE ALL-STAR**: Deni is above average in {metrics_above} category with a {avg_percentile:.0f}th percentile ranking. "
                        f"His versatile game and improving production suggest he's on the trajectory toward All-Star status. With continued development "
                        f"in scoring efficiency and consistent playmaking, he's knocking on the door of All-Star recognition."
                    )
                else:
                    st.info(
                        f"ðŸ“ˆ **DEVELOPING STAR**: Deni shows promise with a {avg_percentile:.0f}th percentile ranking across key metrics. While below "
                        f"All-Star averages currently, his all-around skill set, size, and basketball IQ provide a strong foundation for future growth. "
                        f"His unique combination of abilities suggests he's building toward All-Star caliber production."
                    )
            
            # New Scouting Visualizations
            st.markdown("---")
            st.markdown("### Advanced Scouting Visualizations")
            
            # The Separation Chart
            st.markdown("#### The Separation Chart: Usage vs Efficiency")
            st.markdown("Compare Deni's efficiency (True Shooting %) against his usage rate, relative to All-Stars. **Elite players typically occupy the high-usage, high-efficiency quadrant.** This chart helps identify players who can maintain efficiency even with high offensive responsibilityâ€”a key trait of All-Star caliber talent.")
            
            if not allstar_detailed_df.empty and len(allstar_detailed_df) > 0:
                separation_fig = plot_separation_chart(allstar_detailed_df, deni_stats, career_df)
                st.plotly_chart(separation_fig, use_container_width=True)
            else:
                st.warning("âš ï¸ Detailed All-Star stats (Usage/TS%) not available for separation chart.")
            
            # The Triple Threat
            st.markdown("#### The Triple Threat: 3D All-Around Game")
            st.write("Visualize Deni's all-around production (Points, Rebounds, Assists) in 3D space compared to All-Stars. This shows if he's a volume contributor or specialist.")
            
            triple_threat_fig = plot_triple_threat(allstar_df, deni_stats)
            st.plotly_chart(triple_threat_fig, use_container_width=True)
            
        except Exception as e:
            st.error(f"âŒ Error displaying comparison: {str(e)}")
            st.info("ðŸ’¡ Please try refreshing the page or contact support if the issue persists.")

elif page == "About Me":
    about_me_page()
