"""
Deni Avdija: 360¬∞ Performance Analytics Dashboard

This Streamlit app loads all data from nba_data.pkl (generated by fetch_data.py).
No API calls are made - all data is loaded from the local pickle file.

Before running this app, you must first run: python fetch_data.py
"""

import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
import streamlit as st
import os
import pickle
import numpy as np
from pathlib import Path
from datetime import datetime

# -----------------------------
# Config and constants
# -----------------------------
PLAYER_NAME = "Deni Avdija"
CURRENT_SEASON = "2025-26"
DATA_FILE = "nba_data.pkl"

# Colorblind-Safe Color Palette (Munzner's Principles)
COLOR_POSITIVE = "#2c7bb6"  # Strong Blue/Teal (Made shots, positive metrics)
COLOR_NEGATIVE = "#d7191c"  # Strong Red-Orange (Missed shots, negative metrics)
COLOR_DENI = "#00CC96"      # Distinct Teal for Deni
COLOR_HIGHLIGHT = "#AB63FA" # Purple for highlighted comparisons
COLOR_GRAY = "#636EFA"      # Standard Blue-Gray for others

st.set_page_config(
    page_title="Deni Avdija: 360¬∞ Analytics",
    layout="wide",
    page_icon="üèÄ"
)

# -----------------------------
# Data Loading (from pickle file)
# -----------------------------
@st.cache_data(show_spinner=False)
def load_nba_data() -> dict:
    """Load all NBA data from pickle file."""
    if not Path(DATA_FILE).exists():
        return {}
    
    try:
        with open(DATA_FILE, "rb") as f:
            data = pickle.load(f)
        return data
    except Exception as e:
        st.error(f"‚ùå Error loading data file: {e}")
        return {}

def get_file_mod_time() -> str:
    """Get the last modified time of the data file."""
    if not Path(DATA_FILE).exists():
        return "N/A"
    try:
        mod_time = os.path.getmtime(DATA_FILE)
        return datetime.fromtimestamp(mod_time).strftime("%Y-%m-%d %H:%M")
    except Exception:
        return "N/A"

# -----------------------------
# Transform helpers
# -----------------------------
def merge_career_frames(basic_df: pd.DataFrame, adv_df: pd.DataFrame) -> pd.DataFrame:
    """Merge basic and advanced frames on SEASON_ID."""
    if basic_df.empty or adv_df.empty:
        return pd.DataFrame()
    adv_cols = ["SEASON_ID", "NET_RATING", "AST_TO", "TS_PCT", "USG_PCT"]
    missing_cols = [c for c in adv_cols if c not in adv_df.columns]
    if missing_cols:
        pass # Silently handle missing columns
    merged = basic_df.merge(adv_df[adv_cols], on="SEASON_ID", how="inner")
    merged = merged.sort_values("SEASON_ID")
    return merged

# -----------------------------
# Plot builders
# -----------------------------
def plot_per_game_stats(df: pd.DataFrame) -> go.Figure:
    fig = go.Figure()
    metrics = ["PTS", "REB", "AST"]
    colors = [COLOR_POSITIVE, "#2ca02c", "#ff7f0e"] 
    
    for metric, color in zip(metrics, colors):
        fig.add_trace(go.Bar(
            name=metric, x=df["SEASON_ID"], y=df[metric], marker_color=color,
            hovertemplate=f"{metric}: %{{y:.1f}}<extra></extra>"
        ))
    
    fig.update_layout(title="Per Game Stats (PTS, REB, AST)", barmode="group", hovermode="x unified")
    return fig

def plot_per_36_stats(df: pd.DataFrame) -> go.Figure:
    fig = go.Figure()
    all_metrics = ["PTS", "REB", "AST", "STL", "TOV"]
    colors = [COLOR_POSITIVE, "#2ca02c", "#ff7f0e", "#9467bd", COLOR_NEGATIVE]
    
    # Check if we have MIN column for calculation
    if "MIN" in df.columns:
        for metric, color in zip(all_metrics, colors):
            if metric in df.columns:
                # Calculate Per36
                per36 = df.apply(lambda row: (row[metric] / row["MIN"]) * 36 if row["MIN"] > 0 else 0, axis=1)
                fig.add_trace(go.Bar(
                    name=metric, x=df["SEASON_ID"], y=per36, marker_color=color,
                    hovertemplate=f"{metric} (Per 36): %{{y:.1f}}<extra></extra>"
                ))
    
    fig.update_layout(title="Per 36 Minutes Efficiency", barmode="group", hovermode="x unified")
    return fig

def plot_usage_growth(df: pd.DataFrame) -> go.Figure:
    fig = go.Figure()
    fig.add_trace(go.Scatter(
        x=df["SEASON_ID"], y=df["USG_PCT"], mode="lines+markers", name="Usage %",
        line=dict(color=COLOR_POSITIVE, width=3), marker=dict(size=8),
        hovertemplate="Season: %{x}<br>Usage %: %{y:.2%}<extra></extra>"
    ))
    fig.update_layout(title="Usage Rate Growth", yaxis=dict(tickformat=".0%"), hovermode="x unified")
    return fig

def plot_ts_growth(df: pd.DataFrame) -> go.Figure:
    fig = go.Figure()
    fig.add_trace(go.Scatter(
        x=df["SEASON_ID"], y=df["TS_PCT"], mode="lines+markers", name="True Shooting %",
        line=dict(color="#2ca02c", width=3), marker=dict(size=8),
        hovertemplate="Season: %{x}<br>TS %: %{y:.2%}<extra></extra>"
    ))
    fig.add_hline(y=0.58, line_dash="dash", line_color="gray", annotation_text="League Avg (0.58)")
    fig.update_layout(title="True Shooting % Growth", yaxis=dict(tickformat=".0%"), hovermode="x unified")
    return fig

def plot_allstar_comparison(deni_stats: dict, allstar_df: pd.DataFrame) -> tuple[go.Figure, dict, pd.DataFrame]:
    """Grouped bar chart comparing Deni to All-Star average and bottom 4 entry level."""
    if allstar_df.empty or not deni_stats:
        return go.Figure(), {}, pd.DataFrame()
    
    total_gp = allstar_df["GP"].sum()
    if total_gp == 0: return go.Figure(), {}, pd.DataFrame()
    
    # Weighted Averages
    allstar_pts = round((allstar_df["PTS"] * allstar_df["GP"]).sum() / total_gp, 1)
    allstar_reb = round((allstar_df["REB"] * allstar_df["GP"]).sum() / total_gp, 1)
    allstar_ast = round((allstar_df["AST"] * allstar_df["GP"]).sum() / total_gp, 1)
    
    # Deni Stats
    deni_pts = round(deni_stats.get("PTS", 0), 1)
    deni_reb = round(deni_stats.get("REB", 0), 1)
    deni_ast = round(deni_stats.get("AST", 0), 1)
    
    # Bottom 4 All-Stars
    bottom_4_df = allstar_df.nsmallest(4, "PTS").copy().sort_values("PTS", ascending=True)
    
    categories = ["PTS", "REB", "AST"]
    
    fig = go.Figure()
    
    # Deni
    fig.add_trace(go.Bar(
        name="Deni Avdija (2025-26)", x=categories, y=[deni_pts, deni_reb, deni_ast],
        marker_color=COLOR_DENI, textposition="auto", text=[deni_pts, deni_reb, deni_ast],
        marker=dict(line=dict(width=2, color="black"))
    ))
    
    # Average
    fig.add_trace(go.Bar(
        name="All-Star Average", x=categories, y=[allstar_pts, allstar_reb, allstar_ast],
        marker_color=COLOR_POSITIVE, textposition="auto", text=[allstar_pts, allstar_reb, allstar_ast]
    ))
    
    # Entry Level (Bottom 4)
    for idx, row in bottom_4_df.iterrows():
        fig.add_trace(go.Bar(
            name=f"{row['PLAYER_NAME']} (Entry)", x=categories,
            y=[row["PTS"], row["REB"], row["AST"]],
            marker_color="rgba(200,200,200,0.5)", showlegend=True
        ))

    # Threshold Lines
    fig.add_shape(type="line", x0=-0.5, x1=0.5, y0=allstar_pts, y1=allstar_pts, line=dict(color="red", width=2, dash="dash"))
    fig.add_shape(type="line", x0=0.5, x1=1.5, y0=allstar_reb, y1=allstar_reb, line=dict(color="red", width=2, dash="dash"))
    fig.add_shape(type="line", x0=1.5, x1=2.5, y0=allstar_ast, y1=allstar_ast, line=dict(color="red", width=2, dash="dash"))

    fig.update_layout(title="The All-Star Threshold", barmode="group", hovermode="x unified")
    
    stats_dict = {"allstar_pts": allstar_pts, "allstar_reb": allstar_reb, "allstar_ast": allstar_ast,
                  "deni_pts": deni_pts, "deni_reb": deni_reb, "deni_ast": deni_ast}
    
    return fig, stats_dict, bottom_4_df

def plot_separation_chart(allstar_df: pd.DataFrame, deni_stats: dict, career_df_ref: pd.DataFrame = None, highlight_player: str = None) -> go.Figure:
    """Fixed Separation Chart with Quadrants."""
    # FIX: Initialize Figure FIRST to avoid UnboundLocalError
    fig = go.Figure()

    if allstar_df.empty or not deni_stats:
        fig.update_layout(title="The Separation Chart (No Data)")
        return fig

    # Averages for Quadrants
    avg_usage = (allstar_df["USG_PCT"] * 100).mean()
    avg_ts = (allstar_df["TS_PCT"] * 100).mean()

    # Deni Stats
    deni_usg = deni_stats.get("USG_PCT", 0)
    deni_ts = deni_stats.get("TS_PCT", 0)
    if deni_usg <= 1: deni_usg *= 100
    if deni_ts <= 1: deni_ts *= 100
    
    # Fallback to career stats if missing
    if (deni_usg == 0 or deni_ts == 0) and career_df_ref is not None and not career_df_ref.empty:
        last = career_df_ref.iloc[-1]
        deni_usg = last.get("USG_PCT", 0) * 100
        deni_ts = last.get("TS_PCT", 0) * 100

    # 1. Plot All-Stars (Background)
    others = allstar_df
    if highlight_player and highlight_player != "None":
        others = allstar_df[allstar_df["PLAYER_NAME"] != highlight_player]
        highlighted = allstar_df[allstar_df["PLAYER_NAME"] == highlight_player]
        
        # Plot Highlighted Player
        if not highlighted.empty:
            fig.add_trace(go.Scatter(
                x=highlighted["USG_PCT"]*100, y=highlighted["TS_PCT"]*100,
                mode="markers+text", text=highlighted["PLAYER_NAME"], textposition="top center",
                name=highlight_player, marker=dict(color=COLOR_HIGHLIGHT, size=15, symbol="star")
            ))

    # Plot remaining stars
    fig.add_trace(go.Scatter(
        x=others["USG_PCT"]*100, y=others["TS_PCT"]*100,
        mode="markers", name="All-Stars",
        marker=dict(color=COLOR_GRAY, size=10, opacity=0.6),
        text=others["PLAYER_NAME"], hovertemplate="%{text}<br>USG: %{x:.1f}%<br>TS: %{y:.1f}%"
    ))

    # 2. Plot Deni
    if deni_usg > 0:
        fig.add_trace(go.Scatter(
            x=[deni_usg], y=[deni_ts], mode="markers+text", name="Deni Avdija",
            text=["Deni"], textposition="top center",
            marker=dict(color=COLOR_DENI, size=18, symbol="diamond", line=dict(width=2, color="black"))
        ))

    # 3. Quadrant Lines
    fig.add_vline(x=avg_usage, line_dash="dash", line_color="gray", annotation_text="Avg Usage")
    fig.add_hline(y=avg_ts, line_dash="dash", line_color="gray", annotation_text="Avg TS%")

    # 4. Quadrant Labels (Annotations)
    # Top Right
    fig.add_annotation(x=avg_usage+5, y=avg_ts+5, text="<b>Elite</b><br>(High Use, High Eff)", showarrow=False, font=dict(color="gray"))
    
    fig.update_layout(
        title="Usage vs. Efficiency (Separation Chart)",
        xaxis_title="Usage %", yaxis_title="True Shooting %",
        hovermode="closest"
    )
    return fig

def plot_triple_threat(allstar_df: pd.DataFrame, deni_stats: dict, highlight_player: str = None) -> go.Figure:
    fig = go.Figure()
    
    deni_pts = deni_stats.get("PTS", 0)
    deni_reb = deni_stats.get("REB", 0)
    deni_ast = deni_stats.get("AST", 0)
    
    # All Stars
    fig.add_trace(go.Scatter3d(
        x=allstar_df["PTS"], y=allstar_df["REB"], z=allstar_df["AST"],
        mode="markers", name="All-Stars",
        marker=dict(size=6, color=COLOR_GRAY, opacity=0.6),
        text=allstar_df["PLAYER_NAME"]
    ))
    
    # Highlight
    if highlight_player and highlight_player != "None":
        h_df = allstar_df[allstar_df["PLAYER_NAME"] == highlight_player]
        if not h_df.empty:
            fig.add_trace(go.Scatter3d(
                x=h_df["PTS"], y=h_df["REB"], z=h_df["AST"],
                mode="markers+text", name=highlight_player, text=[highlight_player],
                marker=dict(size=10, color=COLOR_HIGHLIGHT)
            ))

    # Deni
    fig.add_trace(go.Scatter3d(
        x=[deni_pts], y=[deni_reb], z=[deni_ast],
        mode="markers+text", name="Deni Avdija", text=["Deni"],
        marker=dict(size=12, color=COLOR_DENI, symbol="diamond")
    ))
    
    fig.update_layout(title="Triple Threat (3D): Points, Rebounds, Assists", scene=dict(xaxis_title="PTS", yaxis_title="REB", zaxis_title="AST"))
    return fig

def plot_current_season(logs: pd.DataFrame, season: str) -> go.Figure:
    logs = logs.sort_values("GAME_DATE")
    colors = [COLOR_POSITIVE if r == "W" else COLOR_NEGATIVE for r in logs.get("WL", [])]
    
    fig = go.Figure()
    fig.add_trace(go.Bar(x=logs["GAME_DATE"], y=logs["MIN"], marker_color=colors, name="Minutes"))
    fig.add_trace(go.Scatter(x=logs["GAME_DATE"], y=logs["PTS"], mode="lines+markers", yaxis="y2", name="Points", line=dict(color=COLOR_POSITIVE)))
    
    fig.update_layout(
        title=f"{season} Game Log", yaxis=dict(title="Minutes"),
        yaxis2=dict(title="Points", overlaying="y", side="right"), hovermode="x unified"
    )
    return fig

def draw_nba_court(fig=None):
    if fig is None: fig = go.Figure()
    # Shapes for Half Court
    shapes = []
    # Outer
    shapes.append(dict(type="rect", x0=-250, y0=-47.5, x1=250, y1=422.5, line=dict(color="black", width=2)))
    # Hoop
    shapes.append(dict(type="circle", x0=-7.5, y0=-7.5, x1=7.5, y1=7.5, line=dict(color="orange", width=2)))
    # Paint
    shapes.append(dict(type="rect", x0=-80, y0=-47.5, x1=80, y1=142.5, line=dict(color="black", width=2)))
    # 3PT Arc (Simple approx for robustness)
    shapes.append(dict(type="path", path="M -220 -47.5 L -220 92.5 C -220 300, 220 300, 220 92.5 L 220 -47.5", line=dict(color="black", width=2)))
    
    fig.update_layout(
        shapes=shapes,
        xaxis=dict(range=[-250, 250], showgrid=False, visible=False),
        yaxis=dict(range=[-47.5, 422.5], scaleanchor="x", scaleratio=1, showgrid=False, visible=False),
        plot_bgcolor="#f8f8f8", width=600, height=550, margin=dict(l=0, r=0, t=0, b=0)
    )
    return fig

def calculate_shooting_stats(df):
    if df.empty: return {"fgm":0, "fga":0, "pct":0, "paint_pct":0, "mid_pct":0, "3pt_pct":0}
    made = len(df[df["EVENT_TYPE"] == "Made Shot"])
    total = len(df)
    
    # Zones
    df["dist"] = np.sqrt(df["LOC_X"]**2 + df["LOC_Y"]**2)
    is_3pt = df["dist"] > 220
    is_paint = (~is_3pt) & (df["LOC_Y"] < 142.5) & (df["LOC_X"].abs() < 80)
    is_mid = (~is_3pt) & (~is_paint)
    
    def calc_pct(mask):
        sub = df[mask]
        if sub.empty: return 0
        m = len(sub[sub["EVENT_TYPE"] == "Made Shot"])
        return (m / len(sub)) * 100

    return {
        "fgm": made, "fga": total, "pct": (made/total*100) if total else 0,
        "paint_pct": calc_pct(is_paint),
        "mid_pct": calc_pct(is_mid),
        "3pt_pct": calc_pct(is_3pt)
    }

def create_shot_map_figure(df, season, heatmap=True):
    fig = draw_nba_court()
    if df.empty: return fig
    
    made = df[df["EVENT_TYPE"] == "Made Shot"]
    miss = df[df["EVENT_TYPE"] == "Missed Shot"]
    
    fig.add_trace(go.Scatter(x=made["LOC_X"], y=made["LOC_Y"], mode="markers", marker=dict(color=COLOR_POSITIVE, size=6), name="Made"))
    fig.add_trace(go.Scatter(x=miss["LOC_X"], y=miss["LOC_Y"], mode="markers", marker=dict(color=COLOR_NEGATIVE, size=6, symbol="x"), name="Missed"))
    
    fig.update_layout(title=f"Shot Chart: {season}")
    return fig

# -----------------------------
# Main Layout
# -----------------------------
sidebar_header()
page = st.sidebar.radio("Navigate", ["Dashboard", "Detailed Analysis", "Raw Data", "Shot Maps", "Research: Deep Dive", "About Me"])

nba_data = load_nba_data()
if not nba_data:
    st.error("‚ö†Ô∏è Data not found. Run `python fetch_data.py` first.")
    st.stop()

# Unpack Data
career_basic = nba_data.get("career_basic", pd.DataFrame())
career_adv = nba_data.get("career_advanced", pd.DataFrame())
logs_25 = nba_data.get("game_logs_2025_26", pd.DataFrame())
logs_24 = nba_data.get("game_logs_2024_25", pd.DataFrame())
shot_charts = nba_data.get("shot_charts", {})
allstar_df = nba_data.get("allstar_stats", pd.DataFrame())
allstar_detail = nba_data.get("allstar_detailed_stats", pd.DataFrame())

career_df = merge_career_frames(career_basic, career_adv)

# Sidebar Info
last_up = get_file_mod_time()
st.sidebar.info(f"üìÖ Data Updated: {last_up}")

# --- PAGES ---

if page == "Dashboard":
    st.title(f"üìä {PLAYER_NAME}: Dashboard")
    col1, col2 = st.columns(2)
    with col1:
        st.subheader("2025-26 Season")
        st.plotly_chart(plot_current_season(logs_25, "25-26"), use_container_width=True)
    with col2:
        st.subheader("2024-25 Season")
        st.plotly_chart(plot_current_season(logs_24, "24-25"), use_container_width=True)

elif page == "Detailed Analysis":
    st.header("üìà Career Trends")
    if not career_df.empty:
        st.plotly_chart(plot_per_game_stats(career_df), use_container_width=True)
        c1, c2 = st.columns(2)
        c1.plotly_chart(plot_usage_growth(career_df), use_container_width=True)
        c2.plotly_chart(plot_ts_growth(career_df), use_container_width=True)

elif page == "Raw Data":
    st.header("üóÉÔ∏è Raw Data Explorer")
    st.dataframe(career_df, use_container_width=True)

elif page == "Shot Maps":
    st.header("üéØ Shot Selection Analysis")
    
    col_c, col_d = st.columns([1, 3])
    with col_c:
        mode = st.radio("Mode", ["Single Season", "Compare Seasons"])
        s1 = st.selectbox("Season A", ["2022-23", "2023-24", "2024-25", "2025-26"], index=3)
        s2 = None
        if mode == "Compare Seasons":
            s2 = st.selectbox("Season B", ["2022-23", "2023-24", "2024-25", "2025-26"], index=2)
            
    with col_d:
        df1 = shot_charts.get(s1, pd.DataFrame())
        stats1 = calculate_shooting_stats(df1)
        
        if mode == "Single Season":
            c1, c2, c3, c4 = st.columns(4)
            c1.metric("FG%", f"{stats1['pct']:.1f}%")
            c2.metric("Paint", f"{stats1['paint_pct']:.1f}%")
            c3.metric("Mid", f"{stats1['mid_pct']:.1f}%")
            c4.metric("3PT", f"{stats1['3pt_pct']:.1f}%")
            st.plotly_chart(create_shot_map_figure(df1, s1), use_container_width=True)
            
        else: # Compare
            if s1 == s2:
                st.warning("Select different seasons.")
            else:
                df2 = shot_charts.get(s2, pd.DataFrame())
                stats2 = calculate_shooting_stats(df2)
                
                # Comparison Metrics
                st.markdown(f"#### Comparing: {s1} vs {s2}")
                k1, k2, k3, k4 = st.columns(4)
                
                # Deltas (S1 - S2)
                d_fg = stats1['pct'] - stats2['pct']
                d_3pt = stats1['3pt_pct'] - stats2['3pt_pct']
                
                k1.metric("FG% Diff", f"{stats1['pct']:.1f}%", f"{d_fg:+.1f}%", 
                          help=f"{s1}: {stats1['pct']:.1f}% vs {s2}: {stats2['pct']:.1f}%")
                k2.metric("Paint Diff", f"{stats1['paint_pct']:.1f}%", f"{stats1['paint_pct']-stats2['paint_pct']:+.1f}%")
                k3.metric("Mid Diff", f"{stats1['mid_pct']:.1f}%", f"{stats1['mid_pct']-stats2['mid_pct']:+.1f}%")
                k4.metric("3PT Diff", f"{stats1['3pt_pct']:.1f}%", f"{d_3pt:+.1f}%")
                
                # Text Summary
                if d_fg > 0:
                    st.success(f"‚úÖ **Improvement:** {s1} shows a **{d_fg:+.1f}%** better Field Goal Percentage than {s2}.")
                else:
                    st.warning(f"‚ö†Ô∏è **Decline:** {s1} shows a **{d_fg:.1f}%** lower Field Goal Percentage than {s2}.")
                
                # Side by Side
                cc1, cc2 = st.columns(2)
                cc1.plotly_chart(create_shot_map_figure(df1, s1), use_container_width=True)
                cc2.plotly_chart(create_shot_map_figure(df2, s2), use_container_width=True)

elif page == "Research: Deep Dive":
    st.header("üî¨ Deep Dive: All-Star Analysis")
    
    # Deni Stats Calculation
    deni_pts = 25.8 # Default fallback
    deni_reb = 7.2
    deni_ast = 6.3
    
    if not logs_25.empty:
        deni_pts = round(logs_25["PTS"].mean(), 1)
        deni_reb = round(logs_25["REB"].mean(), 1)
        deni_ast = round(logs_25["AST"].mean(), 1)
        
    deni_stats = {"PTS": deni_pts, "REB": deni_reb, "AST": deni_ast}
    
    # 1. Bar Chart
    fig_bar, stats_dict, _ = plot_allstar_comparison(deni_stats, allstar_df)
    st.plotly_chart(fig_bar, use_container_width=True)
    
    # 2. Dynamic Verdict
    st.subheader("üéØ The Analytical Verdict")
    pd1, pd2, pd3 = st.columns(3)
    
    diff_pts = deni_pts - stats_dict['allstar_pts']
    diff_reb = deni_reb - stats_dict['allstar_reb']
    diff_ast = deni_ast - stats_dict['allstar_ast']
    
    pd1.metric("PTS vs Avg", f"{deni_pts}", f"{diff_pts:+.1f}")
    pd2.metric("REB vs Avg", f"{deni_reb}", f"{diff_reb:+.1f}")
    pd3.metric("AST vs Avg", f"{deni_ast}", f"{diff_ast:+.1f}")
    
    good_cats = sum([diff_pts>0, diff_reb>0, diff_ast>0])
    if good_cats >= 2:
        st.success(f"üèÜ **All-Star Caliber:** Deni outperforms the All-Star Average in {good_cats}/3 categories.")
    else:
        st.info(f"üìà **Developing Star:** Deni is approaching All-Star levels.")
        
    # 3. Full Table (FIXED SORTING)
    st.subheader("üìã Full Comparison Table")
    
    # Sort Selector
    sort_key = st.selectbox("Sort Table By:", ["Points", "Rebounds", "Assists"], index=0)
    
    # Prepare Data
    tbl = allstar_df[["PLAYER_NAME", "GP", "PTS", "REB", "AST"]].copy()
    tbl.columns = ["Player", "GP", "Points", "Rebounds", "Assists"]
    
    # Add Deni
    row = pd.DataFrame({"Player": [f"{PLAYER_NAME} (2025-26)"], "GP": [len(logs_25)], 
                        "Points": [deni_pts], "Rebounds": [deni_reb], "Assists": [deni_ast]})
    tbl = pd.concat([tbl, row], ignore_index=True)
    
    # --- CRITICAL FIX: SORT THEN RANK ---
    tbl = tbl.sort_values(sort_key, ascending=False).reset_index(drop=True)
    tbl.insert(0, "Rank", range(1, len(tbl) + 1))
    # ------------------------------------
    
    # Highlight
    def hl(x):
        return ['background-color: yellow' if "Deni" in str(x['Player']) else '' for _ in x]
    
    st.dataframe(tbl.style.apply(hl, axis=1), use_container_width=True, hide_index=True)
    
    # 4. Separation Chart (FIXED BUG)
    st.subheader("Advanced Scouting")
    st.plotly_chart(plot_separation_chart(allstar_detail, {"USG_PCT":0.27, "TS_PCT":0.63}, career_df), use_container_width=True)
    
    # 5. Triple Threat
    st.plotly_chart(plot_triple_threat(allstar_df, deni_stats), use_container_width=True)

elif page == "About Me":
    st.subheader("About Me")
    st.write("Created by Ram Shiri - Data Engineering Student")